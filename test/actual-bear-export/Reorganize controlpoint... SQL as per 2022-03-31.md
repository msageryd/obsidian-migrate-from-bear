# Reorganize controlpoint... SQL as per 2022-03-31

#plantrail/database


`--Alter journal_item, controlpoint, controlpoint_file_ref add some columns`
`ALTER TABLE main.journal_item ADD COLUMN IF NOT EXISTS id int GENERATED BY DEFAULT AS IDENTITY;`
`ALTER TABLE main.journal_item ADD COLUMN IF NOT EXISTS remove_file_guids uuid[];`
`ALTER TABLE main.controlpoint ADD COLUMN IF NOT EXISTS id int GENERATED BY DEFAULT AS IDENTITY;`
`ALTER TABLE main.controlpoint_file_ref ADD COLUMN IF NOT EXISTS journal_item_id int;`
`ALTER TABLE main.controlpoint_file_ref ADD COLUMN IF NOT EXISTS created_by_id int;`
`ALTER TABLE main.controlpoint_file_ref ADD COLUMN IF NOT EXISTS media_album_id smallint;`
`ALTER TABLE main.controlpoint_file_ref DROP CONSTRAINT IF EXISTS controlpoint_file_ref_intent_id_key;`
`ALTER TABLE main.controlpoint_file_ref ADD COLUMN IF NOT EXISTS created_at timestamptz(3);`
`ALTER TABLE main.controlpoint_file_ref ADD COLUMN IF NOT EXISTS modified_at timestamptz(3);`


`--Add all missing media albums`
`INSERT INTO main.media_album `
`(id, name)`
`VALUES (4, 'control'),`
`(5, 'after_surfacePrep'),`
`(6, 'closing'),`
`(7, 'base_info'),`
`(8, 'environment'),`
`(9, 'after_painting'),`
`(10, 'obstacle'),`
`(11, 'deviation')`
`ON CONFLICT DO NOTHING;`

`--Update all existing journal_item_file_refs with media_album_id`
`UPDATE main.journal_item_file_ref ji`
`SET media_album_id = m.id `
`FROM main.media_album m`
`WHERE m.name = ji.tag`
`AND ji.media_album_id IS NULL;`

`--Drop modified_at trigger on controlpoint_file_ref`
`DROP TRIGGER IF EXISTS controlpoint_file_ref__bi_bu__modified_at ON main.controlpoint_file_ref;`

`--Update all existing controlpoint_file_refs (i.e. thumbnail files) with media_album_id and journal_item_id`
`WITH j AS (`
`  SELECT file_guid, controlpoint_guid, ji.id as journal_item_id, media_album_id, jfr.created_at, jfr.created_by_id`
`  FROM journal_item_file_ref jfr `
`  JOIN journal_item ji ON ji.guid = jfr.journal_item_guid`
`)`
`INSERT INTO main.controlpoint_file_ref`
`(controlpoint_guid, file_guid, intent_id, created_at, journal_item_id, media_album_id, created_by_id)`
`SELECT `
`  controlpoint_guid, `
`  file_guid, `
`  5, `
`  created_at, `
`  journal_item_id, `
`  media_album_id,`
`  created_by_id`
`FROM j`
`ON CONFLICT DO NOTHING;`

`--Update all existing controlpoint_file_refs (i.e. thumbnail files) with media_album_id and journal_item_id`
`WITH j AS (`
`  SELECT file_guid, controlpoint_guid, ji.id as journal_item_id, media_album_id, jfr.created_at, jfr.created_by_id`
`  FROM journal_item_file_ref jfr `
`  JOIN journal_item ji ON ji.guid = jfr.journal_item_guid`
`)`
`UPDATE main.controlpoint_file_ref fr`
`SET `
`  journal_item_id = j.journal_item_id, `
`  media_album_id = j.media_album_id,`
`  created_at = j.created_at,`
`  created_by_id = j.created_by_id`
`FROM j`
`WHERE fr.controlpoint_guid = j.controlpoint_guid `
`AND fr.file_guid = j.file_guid;`


`--Recreate controlpoint_with_files. Added media_album`
`DROP VIEW IF EXISTS main.controlpoint_with_files;`

`CREATE VIEW main.controlpoint_with_files AS (`
` SELECT cp.guid,`
`    cp.project_id,`
`    cp.layer_id,`
`    cp.drawing_id,`
`    cp.controlpoint_type_id,`
`    cp.parent_controlpoint_guid,`
`    cp.created_by_id,`
`    cp.created_at,`
`    cp.modified_at,`
`    cp.modified_by_ids,`
`    cp.resolved_by_id,`
`    cp.controlpoint_level_id,`
`    cp.identifier,`
`    cp.identifier_prefix,`
`    cp.symbol_id,`
`    cp.signature_file_guid,`
`    cp.thumbnail_file_guid,`
`    cp.notes,`
`    cp.properties,`
`    cp.target_controlpoint_level_id,`
`    array_to_json(array_agg(json_build_object('fileGuid', fr.file_guid, 'intentId', fr.intent_id, 'mediaAlbumId', fr.media_album_id, 'createdById', fr.created_by_id)) FILTER (WHERE (fr.file_guid IS NOT NULL))) AS file_refs,`
`    array_to_json(array_agg(row_to_json(f.*)) FILTER (WHERE (f.guid IS NOT NULL))) AS files,`
`    cp.is_journal_started,`
`    cp.inspection_guid_lock,`
`    cp.is_auto_deviation`
`   FROM ((main.controlpoint cp`
`     LEFT JOIN main.controlpoint_file_ref fr ON ((fr.controlpoint_guid = cp.guid)))`
`     LEFT JOIN main.file_simple f ON ((f.guid = fr.file_guid)))`
`  GROUP BY cp.guid`
`);`


`   INSERT INTO main.controlpoint_file_ref (`
`     controlpoint_guid,`
`     file_guid,`
`     intent_id,`
`     created_by_id,`
`     created_at,`
`     media_album_id,`
`     journal_item_id`
`   )`
`   SELECT`
`     'b26e8067-317c-4414-9b28-37daf8f1182d',`
`     jfr.file_guid,`
`     jfr.intent_id,`
`     jfr.created_by_id,`
`     jfr.created_at,`
`     m.id as media_album_id,`
`     j.id`
`   FROM main.journal_item_file_ref jfr`
`   JOIN main.journal_item j ON j.guid = jfr.journal_item_guid`
`   LEFT JOIN main.media_album m ON m.name = jfr.tag`
`   WHERE journal_item_guid = '3c65c81f-8a68-42a6-9aa8-56771a853c04'`
`   ON CONFLICT DO NOTHING; --should never conflict, but just in case..`

`-------------------------`

`CREATE OR REPLACE FUNCTION main.process_journal_item(_journal_item journal_item)`
` RETURNS integer`
` LANGUAGE plpgsql`
`AS $function$`
`DECLARE`
`  _controlpoint main.controlpoint;`
`  _resolvable_deviation_type_ids int[];`
`  _clear_property_fields varchar[];`
`  _try_to_resolve_deviation_type_ids int[];`
`  _try_to_create_deviation_type_ids int[];`
`  _creatable_deviation_type_ids int[];`
`  _create_mandatory_deviation_type_ids int[];`
`  _only_own_controlpoint boolean;`
`  _is_update_resolved_by_id boolean;`
`  _initial_deviation_type_id int;`
`  _journal_item_type_definition json;`
`  `
`  _last_controlpoint_level_id int;`
`  _last_controlpoint_type_id int = NULL;`

`  _old_drawing_id int;`
`  _new_drawing_id int;`

`  _old_layer_id int;`
`  _new_layer_id int;`

`  _new_identifier int;`

`  --Variables for processing _journal_item.share`
`  _recipients json[];`
`  _distribution_title varchar;`
`  _distribution_message varchar;`
`  _report_type_id int;`
`  _project_id int;`
`  _report_filter json;`
`  _report_guid uuid;`
`  _report_properties json;`
`  _report_language_code varchar;`

`  _sequence_scope_id smallint;`
`BEGIN`
`  --insert into log.debug (info) VALUES (_);`

`  --Get current data from the controlpoint`
`  SELECT INTO _controlpoint *`
`  FROM main.controlpoint`
`  WHERE guid = _journal_item.controlpoint_guid;`


`  --======================================================================================`
`  --Ensure that inspection lock on the controlpoint is honored`
`  --======================================================================================`
`    --If the controlpoint has an inspection lock, journal items must be tagged with this inspection guid`
`    IF _controlpoint.inspection_guid_lock != NULL THEN`

`      IF _journal_item.inspection_guid != _controlpoint.inspection_guid_lock THEN`
`        RAISE EXCEPTION 'process_journal_item:: This controlpoint (%) is locked to inspection (%). The journal item cannot be saved because it is not tagged with this inspection',`
`          _controlpoint.guid,`
`          _controlpoint.inspection_guid_lock`
`          USING ERRCODE = 'S3GA2';`
`      END IF;`
`    END IF;`

`  --======================================================================================`
`  --Initial journalItem (type=-1) is only allowed when the controlpoint is just created`
`  --======================================================================================`
`  IF _journal_item.journal_item_type_id = -1 THEN`
`    IF _controlpoint.is_journal_started = true THEN`
`      RAISE EXCEPTION 'This journalItemType (%) can only be applied when the controlpoint is new, i.e. no other journalItems exists',`
`        _journal_item.journal_item_type_id `
`        USING ERRCODE = 'S3GA2';`
`    END IF;`

`    --If the journal item has an inspection guid, we will lock the newly created controlpoint to this inspection`
`    _controlpoint.inspection_guid_lock = _journal_item.inspection_guid;`
`  END IF;`

`  --======================================================================================`
`  --Gather some data for updating statistics later on`
`  --======================================================================================`
`  --If this is the initial journalItem (type=-1), leave _last_controlpoint_level_id as NULL`
`  IF _journal_item.journal_item_type_id <> -1 THEN`
`    _last_controlpoint_level_id = _controlpoint.controlpoint_level_id;`
`  END IF;`

`  --We need to remember what the current controlpointType is in order to identify a type change while updating statistics`
`  _last_controlpoint_type_id = _controlpoint.controlpoint_type_id;`

`  --======================================================================================`
`  --Get info about the journalItemType`
`  --======================================================================================`
`  SELECT `
`    definition::json`
`  INTO `
`    _journal_item_type_definition`
`  FROM main.journal_item_type`
`  WHERE id = _journal_item.journal_item_type_id;`

`  _only_own_controlpoint = (_journal_item_type_definition #>> '{preconditions, onlyOnOwnControlpoints}')::bool;`
`  _is_update_resolved_by_id = (_journal_item_type_definition #>> '{effects, isUpdateResolvedById}')::bool;`

`  --======================================================================================`
`  --Check compliance against "only own controlpoint" rules`
`  --======================================================================================`
`  IF _only_own_controlpoint THEN`
`    IF array_position(_controlpoint.modified_by_ids, _journal_item.created_by_id) IS NULL THEN`
`      RAISE EXCEPTION 'This journalItemType (%) can only be applied on own controlpoints. User (%) does not own this controlpoint',`
`      _journal_item.journal_item_type_id,`
`      _journal_item.created_by_id USING ERRCODE = 'S3GA0';`
`    END IF;`
`    IF array_length(_controlpoint.modified_by_ids, 1) > 1 THEN`
`      RAISE EXCEPTION 'This journalItemType (%) can only be applied on own controlpoints. User (%) is not the only owner of this controlpoint',`
`      _journal_item.journal_item_type_id,`
`      _journal_item.created_by_id USING ERRCODE = 'S3GA0';`
`    END IF;`
`  END IF;`

`  --======================================================================================`
`  -- Resolve deviations`
`  --======================================================================================`
`  --If this journalItem should resolve any deviations, mark these deviations as resolved`
`  IF _journal_item.resolve_deviation_guids IS NOT NULL THEN`
`    --Which deviation types does this journalItem try to resolve?`
`    SELECT INTO _try_to_resolve_deviation_type_ids`
`      array_agg(deviation_type_id)`
`    FROM main.controlpoint_deviation`
`    WHERE guid = ANY(_journal_item.resolve_deviation_guids);`

`    --Which deviationTypes can be resolved by this journalItemType?`
`    SELECT INTO _resolvable_deviation_type_ids`
`      array_agg(deviation_type_id)`
`    FROM main.journal_item_type_resolve_deviation_type`
`    WHERE journal_item_type_id = _journal_item.journal_item_type_id`
`    GROUP BY journal_item_type_id;`

`    --If any of the "_try_to_resolve_deviation_type_ids" referenses deviationTypes that are NOT`
`    --resolvable by this particular journalItemType we can't go on`
`    IF NOT _resolvable_deviation_type_ids @> _try_to_resolve_deviation_type_ids THEN`
`      RAISE EXCEPTION 'One or more of the deviation types (%) cannot be resolved with this journal_item_type (%). Valid deviation types are (%)',`
`        _try_to_resolve_deviation_type_ids,`
`        _journal_item.journal_item_type_id,`
`        _resolvable_deviation_type_ids `
`        USING ERRCODE = 'S3GA2';`
`    END IF;`
`    UPDATE main.controlpoint_deviation`
`    SET resolved_by_journal_item_guid = _journal_item.guid`
`    WHERE (guid = ANY(_journal_item.resolve_deviation_guids));`
`  END IF;`

`  --======================================================================================`
`  -- Create deviations as per _journal_item.create_deviations (or the automatic type -1 as the first deviation)`
`  --======================================================================================`
`  --Which deviation types does this journalItem try to create?`
`  SELECT INTO _try_to_create_deviation_type_ids`
`    COALESCE(array_agg((deviation->>'deviationTypeId')::int), ARRAY[]::int[])`
`  FROM unnest(_journal_item.create_deviations) as deviation;`

`  --Which deviationTypes MUST be createdby this journalItemType?`
`  SELECT INTO _create_mandatory_deviation_type_ids`
`    COALESCE(array_agg(deviation_type_id), ARRAY[]::int[])`
`  FROM main.journal_item_type_create_deviation_type`
`  WHERE journal_item_type_id = _journal_item.journal_item_type_id`
`  AND is_optional = false;`

`  --Which deviationTypes CAN be createdby this journalItemType?`
`  SELECT INTO _creatable_deviation_type_ids`
`    COALESCE(array_agg(deviation_type_id), ARRAY[]::int[])`
`  FROM main.journal_item_type_create_deviation_type`
`  WHERE journal_item_type_id = _journal_item.journal_item_type_id;`

`  --If any mandatory deviationTypes are missing from the instructions in the journalItem we will raise`
`  --We could technically create all mandatory deviations automatically, but this could mean that the client`
`  --did not register these deviations, hence the client would show false information when in off-line mode`
`  --By raising on this problem we ensure that clients are behaving as they should`
`  IF NOT _try_to_create_deviation_type_ids @> _create_mandatory_deviation_type_ids THEN`
`    RAISE EXCEPTION 'One or more of the mandatory deviation types (%) are not included in the journalItems deviationList (%)',`
`      _create_mandatory_deviation_type_ids,`
`      _try_to_create_deviation_type_ids USING ERRCODE = 'S3GA7';`
`  END IF;`
`--    INSERT INTO log.debug (info) VALUES ('try to create deviations: ' || array_to_string(_try_to_create_deviation_type_ids, ','));`
`--    INSERT INTO log.debug (info) VALUES ('mandatory deviations: ' || array_to_string(_create_mandatory_deviation_type_ids, ','));`

`  IF _journal_item.create_deviations IS NOT NULL THEN`
`    --If any of the "_try_to_create_deviation_type_ids" referenses deviationTypes that are NOT`
`    --creatable by this particular journalItemType we can't go on`
`    IF NOT _creatable_deviation_type_ids @> _try_to_create_deviation_type_ids THEN`
`      RAISE EXCEPTION 'One or more of the deviation types (%) cannot be created with this journal_item_type (%). Valid deviation types are (%)',`
`        _try_to_create_deviation_type_ids,`
`        _journal_item.journal_item_type_id,`
`        _creatable_deviation_type_ids USING ERRCODE = 'S3GA7';`
`    END IF;`

`    --If multiple deviations exists with the same deviationTypeId we take only one of them`
`    --If any of them has an assignment this item will be prioritized`
`    --Else if any of them has a dueDate we use the item with the earliest date`
`    --The client really SHOULD handle the uniqueness locally to ensure consistensy in the local (off line) store`
`    --but we have to protect the database if faulty (non unique) data arrives`
`    INSERT INTO main.controlpoint_deviation as d`
`    (guid, controlpoint_guid, created_by_journal_item_guid, deviation_type_id, due_date, assignment)`
`    SELECT DISTINCT ON (deviation_type_id, created_by_journal_item_guid)`
`      (deviation->>'guid')::uuid as guid,`
`      _journal_item.controlpoint_guid,`
`      _journal_item.guid as  created_by_journal_item_guid,`
`      (deviation->>'deviationTypeId')::int as deviation_type_id,`
`      (deviation->>'dueDate')::timestamptz as due_date,`
`      (deviation->>'assignment')::jsonb as assignment`
`    FROM unnest(_journal_item.create_deviations) as deviation`
`    ORDER BY deviation_type_id, created_by_journal_item_guid,assignment, due_date;`
`  END IF;`

`  --Set the controlpointLevel according to the lowest level for all outstanding deviations`
`/*`
`  SELECT INTO _controlpoint.controlpoint_level_id`
`    MIN(dt.controlpoint_level_id)`
`  FROM main.controlpoint_deviation cd`
`  JOIN main.deviation_type dt ON dt.id = cd.deviation_type_id`
`  WHERE controlpoint_guid = _controlpoint.guid`
`  AND (resolved_by_journal_item_guid IS NULL)`
`  AND (dt.controlpoint_level_id IS NOT NULL);`
`*/`
`  SELECT `
`    dt.controlpoint_level_id,`
`    CASE WHEN dt.is_auto_deviation = true THEN true ELSE null END`
`  INTO `
`    _controlpoint.controlpoint_level_id,`
`    _controlpoint.is_auto_deviation`
`  FROM main.controlpoint_deviation cd`
`  JOIN main.deviation_type dt ON dt.id = cd.deviation_type_id`
`  WHERE controlpoint_guid = _controlpoint.guid`
`  AND (resolved_by_journal_item_guid IS NULL)`
`  AND (dt.controlpoint_level_id IS NOT NULL)`
`  ORDER BY dt.controlpoint_level_id, dt.id`
`  LIMIT 1;`
`  `
`  --If no unresolved deviations exists we will get controlpoint_level_id = null`
`  --This means "approved", i.e. the level should be set to 1000`
`  IF(_controlpoint.controlpoint_level_id IS NULL) THEN `
`    _controlpoint.controlpoint_level_id = COALESCE(_journal_item.target_controlpoint_level_id, _controlpoint.target_controlpoint_level_id, 1000);`
`    _controlpoint.is_auto_deviation = NULL;`
`  END IF;`

`  _controlpoint.thumbnail_file_guid = COALESCE(_journal_item.thumbnail_file_guid, _controlpoint.thumbnail_file_guid);`
`  _controlpoint.signature_file_guid = COALESCE(_journal_item.signature_file_guid, _controlpoint.signature_file_guid);`
`    _controlpoint.notes = COALESCE(_journal_item.notes, _controlpoint.notes);`
`  _controlpoint.target_controlpoint_level_id = COALESCE(_journal_item.target_controlpoint_level_id, _controlpoint.target_controlpoint_level_id);`
`  _controlpoint.symbol_id = COALESCE(_journal_item.symbol_id, _controlpoint.symbol_id);`
`  _controlpoint.parent_controlpoint_guid = COALESCE(_journal_item.parent_controlpoint_guid, _controlpoint.parent_controlpoint_guid);`
`  _controlpoint.properties = COALESCE(_controlpoint.properties, '{}'::jsonb) || COALESCE(_journal_item.properties, '{}'::jsonb);`

`  _controlpoint.modified_by_ids = COALESCE(_controlpoint.modified_by_ids, array[]::int[]);`
`  IF array_position(_controlpoint.modified_by_ids, _journal_item.created_by_id) IS NULL THEN`
`    _controlpoint.modified_by_ids = _controlpoint.modified_by_ids || _journal_item.created_by_id;`
`  END IF;`
`  IF _is_update_resolved_by_id THEN`
`    _controlpoint.resolved_by_id = _journal_item.created_by_id;`
`  END IF;`

`  --======================================================================================`
`  -- Clear property fields in the controlpoint as per journal_item_type_clear_property_field`
`  --======================================================================================`
`  SELECT INTO _clear_property_fields`
`    array_agg(name)`
`  FROM main.journal_item_type_clear_property_field`
`  WHERE journal_item_type_id = _journal_item.journal_item_type_id;`

`  --Clear the fields`
`  IF _clear_property_fields IS NOT NULL THEN`
`    _controlpoint.properties = _controlpoint.properties - _clear_property_fields;`
`  END IF;`
`  ---------------------------------------------------------------------------------------`

`  IF _controlpoint.controlpoint_level_id = -99 THEN`
`    _controlpoint.deleted_at = now();`
`    _controlpoint.deleted_by_id = _journal_item.created_by_id;`
`  END IF;`

`  --Update state`
`  IF _journal_item.add_state_ids IS NOT NULL THEN`
`    INSERT INTO main.controlpoint_state`
`    (controlpoint_guid, state_id)`
`    SELECT _controlpoint.guid, unnest(_journal_item.add_state_ids)`
`    ON CONFLICT ON CONSTRAINT controlpoint_state_pkey DO NOTHING;`
`  END IF;`
`  IF _journal_item.remove_state_ids IS NOT NULL THEN`
`    DELETE FROM main.controlpoint_state`
`    WHERE controlpoint_guid = _controlpoint.guid`
`    AND state_id = ANY(_journal_item.remove_state_ids);`
`  END IF;`
`  -------------------------------------------------------------`

`  --Update qr tokens`
`  IF _journal_item.add_qr_tokens IS NOT NULL THEN`
`    INSERT INTO main.controlpoint_qr_token`
`    (controlpoint_guid, qr_token)`
`    SELECT _controlpoint.guid, unnest(_journal_item.add_qr_tokens)`
`    ON CONFLICT DO NOTHING;`
`  END IF;`
`  IF _journal_item.remove_qr_tokens IS NOT NULL THEN`
`    DELETE FROM main.controlpoint_qr_token`
`    WHERE controlpoint_guid = _controlpoint.guid`
`    AND qr_token = ANY(_journal_item.remove_qr_tokens);`
`  END IF;`
`  -------------------------------------------------------------`

`  --Insert/Update shapes`
`  IF _journal_item.shapes IS NOT NULL THEN`
`    INSERT INTO main.controlpoint_shape`
`    (guid, controlpoint_guid, shape)`
`    SELECT`
`      shapes.key::uuid,`
`      _controlpoint.guid,`
`      shapes.value::jsonb`
`    FROM jsonb_each(_journal_item.shapes) as shapes`
`    ON CONFLICT ON CONSTRAINT controlpoint_shape_pkey DO UPDATE SET shape = EXCLUDED.shape;`
`  END IF;`

`  --Remove shapes`
`  IF _journal_item.remove_shape_guids IS NOT NULL THEN`
`    DELETE FROM main.controlpoint_shape`
`    WHERE controlpoint_guid = _controlpoint.guid`
`    AND guid = ANY(_journal_item.remove_shape_guids);`
`  END IF;`
`  -------------------------------------------------------------`

`  --Move to another drawing if journalItems new_drawingId differs from the current drawing_id of the controlpoint`
`  -------------------------------------------------------------`
`  IF _journal_item.new_drawing_id IS NOT NULL `
`  AND _journal_item.new_drawing_id != _controlpoint.drawing_id THEN`
`    --Maybe we need to perform some acl checks here?`
`    _old_drawing_id = _controlpoint.drawing_id;`
`    _new_drawing_id = _journal_item.new_drawing_id;`

`    IF _controlpoint.parent_controlpoint_guid IS NOT NULL THEN`
`      RAISE EXCEPTION 'process_journal_item:: Cannot move controlpoint % between drawings when it is bound to another controlpoint (%)',`
`        _controlpoint.guid,`
`        _controlpoint.parent_controlpoint_guid;`
`    END IF;`

`    --Ensure that both drawings belong to the same project;`
`    SELECT d1.project_id`
`    FROM main.drawing d1`
`    JOIN drawing d2 ON d1.project_id = d2.project_id`
`    WHERE d1.id = _new_drawing_id`
`    AND d2.id = _old_drawing_id;`
`    IF NOT FOUND THEN`
`      RAISE EXCEPTION 'process_journal_item:: Cannot move controlpoint % to non-existing drawing or drawing in another project (from drawing % to %)',`
`        _controlpoint.guid,`
`        _old_drawing_id,`
`        _new_drawing_id;`
`    END IF;`

`    _controlpoint.drawing_id = _new_drawing_id;`
`  END IF;`
`  -------------------------------------------------------------`

`  --Move to another layer if journalItems new_layer_id differs from the current layer_id of the controlpoint`
`  -------------------------------------------------------------`
`  IF _journal_item.new_layer_id IS NOT NULL `
`  AND _journal_item.new_layer_id != _controlpoint.layer_id THEN`
`    --Maybe we need to perform some acl checks here?`
`    _old_layer_id = _controlpoint.layer_id;`
`    _new_layer_id = _journal_item.new_layer_id;`
`    IF _controlpoint.parent_controlpoint_guid IS NOT NULL THEN`
`      RAISE EXCEPTION 'process_journal_item:: Cannot move controlpoint % between layers when it is bound to another controlpoint (%)',`
`        _controlpoint.guid,`
`        _controlpoint.parent_controlpoint_guid;`
`    END IF;`

`    --Ensure that the new layer exists`
`    PERFORM * FROM main.project_layer`
`    WHERE project_id = _controlpoint.project_id`
`    AND layer_id = _new_layer_id;`

`    IF NOT FOUND THEN`
`      RAISE EXCEPTION 'process_journal_item:: Cannot move controlpoint % to non-existing layer (from layer % to %) in project %',`
`        _controlpoint.guid,`
`        _old_layer_id,`
`        _new_layer_id,`
`        _controlpoint.project_id;`
`    END IF;`

`    _controlpoint.layer_id = _new_layer_id;`
`  END IF;`

`  -------------------------------------------------------------`
`  --Do we need a new identifier?`
`  --It depends on the sequence-scope..`
`  --If scope = 1 (project) no new identifier is needed even if drawing and or layer has changed`
`  IF _new_layer_id IS NOT NULL `
`  OR _new_drawing_id IS NOT NULL `
`  THEN`
`    SELECT sequence_scope_id `
`    INTO _sequence_scope_id `
`    FROM main.project_controlpoint_type `
`    WHERE project_id = _controlpoint.project_id`
`    AND controlpoint_type_id = _controlpoint.controlpoint_type_id;`

`    IF _sequence_scope_id = 4 `
`    OR (_sequence_scope_id = 2 AND _new_drawing_id IS NOT NULL)`
`    OR (_sequence_scope_id = 3 AND _new_layer_id IS NOT NULL)`
`    THEN `
`      SELECT main.get_next_project_sequence_value(`
`        _project_id => _controlpoint.project_id,`
`        _controlpoint_type_id => _controlpoint.controlpoint_type_id,`
`        _drawing_id => COALESCE(_new_drawing_id, _controlpoint.drawing_id),`
`        _layer_id => COALESCE(_new_layer_id, _controlpoint.layer_id)`
`      ) INTO _new_identifier;`

`      _controlpoint.identifier = _new_identifier;`
`    END IF;`
`  END IF;`
`  -------------------------------------------------------------`

`  --Insert/Update last_journal_item if local_properties exists`
`  IF _journal_item.local_properties IS NOT NULL THEN`
`    INSERT INTO main.controlpoint_last_journal_item`
`    (controlpoint_guid, local_properties, created_at, created_by_id)`
`    SELECT`
`      _controlpoint.guid,`
`      _journal_item.local_properties,`
`      _journal_item.created_at,`
`      _journal_item.created_by_id`
`    ON CONFLICT ON CONSTRAINT controlpoint_last_journal_item_pkey`
`    DO UPDATE SET`
`      local_properties = EXCLUDED.local_properties,`
`      created_at = EXCLUDED.created_at,`
`      created_by_id = EXCLUDED.created_by_id;`
`  END IF;`
`  -------------------------------------------------------------`
`  --Update delta statistics`
`  -------------------------------------------------------------`

`  --TODO: update stats if drawing_id has changed!`
`  --update: Not needed. We move complete statistics delta if controlpoint is moved`

`  --If controlpointType hasn't changed due to this journalItem, we'll update stats for this type`
`  IF _controlpoint.controlpoint_type_id = _last_controlpoint_type_id THEN`
`--perform app_api.create_debug_info(1,`
`--  json_build_object(`
`--    'controlpointLevelId', _controlpoint.controlpoint_level_id,`
`--    'lastControlpointLevelId', _last_controlpoint_level_id,`
`--    'controlpointTypeId', _controlpoint.controlpoint_type_id,`
`--    'lastControlpointTypeId', _last_controlpoint_type_id`
`--   ),`
`--null);`

`    --but only if the level has changed`
`    IF _controlpoint.controlpoint_level_id <> _last_controlpoint_level_id OR _last_controlpoint_level_id IS NULL THEN`
`      INSERT INTO main.drawing_statistics_delta (`
`        journal_item_guid, `
`        controlpoint_level_id, `
`        delta`
`      )`
`      VALUES (`
`        _journal_item.guid, `
`        _controlpoint.controlpoint_level_id, `
`        +1`
`      );`

`      --If there was a prior level, let's deduct this from the statistics`
`      IF _last_controlpoint_level_id IS NOT NULL THEN`
`        INSERT INTO main.drawing_statistics_delta (`
`        	journal_item_guid, `
`        	controlpoint_level_id, `
`        	delta`
`        )`
`        VALUES (`
`        	_journal_item.guid,`
`        	_last_controlpoint_level_id, `
`        	-1`
`        );`
`      END IF;`
`    END IF;`
`  ELSE`

`    --If controlpointType has changed we need to update statistics whether the level has changed or not`
`    INSERT INTO main.drawing_statistics_delta (`
`	    journal_item_guid, `
`      controlpoint_level_id, `
`      delta`
`    )`
`    VALUES (`
`      _journal_item.guid, `
`      _controlpoint.controlpoint_level_id, `
`      +1`
`    );`

`    --If there was a prior level for the prior controlpointType, let's deduct this from the statistics`
`    IF _last_controlpoint_level_id IS NOT NULL THEN`
`      INSERT INTO main.drawing_statistics_delta (`
`      	journal_item_guid, `
`      	controlpoint_level_id, `
`      	delta`
`      )`
`      VALUES (`
`      	_journal_item.guid, `
`      	_last_controlpoint_level_id, `
`      	-1`
`      );`
`    END IF;`
`  END IF;`

`  --======================================================================================`
`  --Populate controlpoint_product with data from the field journal_item.products`
`  --======================================================================================`
`  --If intentId exists in the journalItem we intend to save our product selection`
`  --Before saving the new selection we want to clear any previous selections`
`  --I.e. product selections are immutable per intentId`
`  IF _journal_item.product_intent_id IS NOT NULL THEN`
`    DELETE FROM main.controlpoint_product`
`    WHERE controlpoint_guid = _controlpoint.guid`
`    AND intent_id = _journal_item.product_intent_id;`
`  END IF;`

`  --If any new products are selected we want to save those.`
`  --N.B if no new products are selected, the result is that all products for this intent are`
`  --removed from the controlpoint. The client UI should probably present the previous selection`
`  --set as selected in order to visualize what's going to happen. If the user does nothing we`
`  --will replace the old set with a new identical set. The user don't need to realise that`
`  --product selections are immutable`
`  IF _journal_item.products IS NOT NULL THEN`
`     INSERT INTO main.controlpoint_product (`
`       controlpoint_guid,`
`       product_id,`
`       properties,`
`       intent_id,`
`       created_by_id`
`     )`
`     SELECT`
`       _controlpoint.guid,`
`       (product->>'productId')::int,`
`       (product->>'properties')::jsonb,`
`       _journal_item.product_intent_id,`
`       _journal_item.created_by_id`
`     FROM unnest(_journal_item.products) as product`
`     ON CONFLICT (controlpoint_guid, product_id, intent_id) DO`
`     UPDATE SET`
`       properties = EXCLUDED.properties,`
`       created_by_id = _journal_item.created_by_id;`
`   END IF;`


`  --======================================================================================`
`  --Update controlpoint_snippet from journal_item.add_snippet and journal_item.remove_snippet`
`  --======================================================================================`
`   IF _journal_item.add_snippets IS NOT NULL THEN`
`     INSERT INTO main.controlpoint_snippet (`
`       controlpoint_guid,`
`       snippet_guid,`
`       intent_id,`
`       created_by_id`
`     )`
`     SELECT`
`       _controlpoint.guid,`
`       (snippet->>'guid')::uuid,`
`       (snippet->>'intentId')::smallint,`
`       _journal_item.created_by_id`
`     FROM unnest(_journal_item.add_snippets) as snippet`
`     ON CONFLICT (controlpoint_guid, snippet_guid, intent_id) DO`
`     UPDATE SET`
`       created_by_id = _journal_item.created_by_id;`
`   END IF;`

`   IF _journal_item.remove_snippets IS NOT NULL THEN`
`      --TODO: delete snippets`
`   END IF;`

`  --======================================================================================`
`  --Insert or delete from controlpoint_file_ref based on journal_item_file_ref and journal_item.remove_file_guids`
`  --======================================================================================`
`   INSERT INTO main.controlpoint_file_ref (`
`     controlpoint_guid,`
`     file_guid,`
`     intent_id,`
`     created_by_id,`
`     created_at,`
`     media_album_id,`
`     journal_item_id`
`   )`
`   SELECT`
`     _controlpoint.guid,`
`     jfr.file_guid,`
`     jfr.intent_id,`
`     jfr.created_by_id,`
`     jfr.created_at,`
`     m.id as media_album_id,`
`     j.id`
`   FROM main.journal_item_file_ref jfr`
`   JOIN main.journal_item j ON j.guid = jfr.journal_item_guid`
`   LEFT JOIN main.media_album m ON m.name = jfr.tag`
`   WHERE journal_item_guid = _journal_item.guid`
`   ON CONFLICT DO NOTHING; --should never conflict, but just in case..`

`   IF _journal_item.remove_file_guids IS NOT NULL THEN`
`      --TODO: delete from controlpoint_file_ref`
`   END IF;`

`  --======================================================================================`
`  --Order report rendering and distribution if journal_item.sharing is populated`
`  --======================================================================================`
`  --If intentId exists in the journalItem we intend to save our product selection`
`  --Before saving the new selection we want to clear any previous selections`
`  --I.e. product selections are immutable per intentId`
`  IF _journal_item.sharing IS NOT NULL THEN`
`    SELECT d.project_id`
`    INTO _project_id`
`    FROM main.drawing d`
`    JOIN main.controlpoint cp `
`      ON cp.drawing_id = d.id `
`      AND cp.guid = _journal_item.controlpoint_guid;`

`    _report_guid = pgcrypto.gen_random_uuid();`
`    _distribution_message = _journal_item.sharing ->> 'message';`
`    _distribution_title = _journal_item.sharing ->> 'title';`
`    _report_language_code = COALESCE((_journal_item.sharing ->> 'languageCode'), 'en');`
`    _report_type_id = COALESCE((_journal_item.sharing ->> 'reportTypeId')::int, 5001);`
`    _report_filter = jsonb_build_object(`
`      'controlpointGuid', _journal_item.controlpoint_guid`
`    );`

`    SELECT array_agg(d.recipient)`
`    INTO _recipients`
`    FROM jsonb_array_elements(_journal_item.sharing -> 'recipients') AS d(recipient);`

`    _report_properties = jsonb_build_object(`
`      'title', _distribution_title,`
`      'message', _distribution_message,`
`      'languageCode', _report_language_code,`
`		  'isIncludeBlueprintCrop', true,`
`		  'isIncludeBlueprintOverview', true`
`		);`

`    PERFORM app_api.create_report(`
`      _user_account_id => _journal_item.created_by_id,`
`      _project_id => _project_id,`
`      _report_type_id => _report_type_id,`
`      _guid => _report_guid,`
`      _filter => _report_filter,`
`      _recipients => _recipients,`
`      _properties => _report_properties,`
`      `
`      --This way we can create and distribute the report without explicit rights`
`      --apparently we do have permission to the journal_item_type, so the implied permission is reasonable`
`      _is_implied_permission => true `
`    );`

`    --Connect this journalItem with the report`
`    INSERT INTO main.journal_item_report`
`    (journal_item_guid, report_guid)`
`    VALUES (_journal_item.guid, _report_guid);`
`  END IF;`

`  ----------------------------------------------------------------------------------------`
`  UPDATE main.controlpoint`
`  SET`
`    modified_at = now(),`
`    is_journal_started = true, --If we arrive here, the journal is started`
`    controlpoint_level_id = _controlpoint.controlpoint_level_id,`
`    is_auto_deviation = _controlpoint.is_auto_deviation,`
`    thumbnail_file_guid = _controlpoint.thumbnail_file_guid,`
`    signature_file_guid = _controlpoint.signature_file_guid,`
`    identifier = _controlpoint.identifier, --Identifier might be updated if layer och drawing has changed`
`    symbol_id = _controlpoint.symbol_id,`
`    parent_controlpoint_guid = _controlpoint.parent_controlpoint_guid,`
`    properties = _controlpoint.properties,`
`    notes = _controlpoint.notes,`
`    deleted_at = _controlpoint.deleted_at,`
`    deleted_by_id = _controlpoint.deleted_by_id,`
`    modified_by_ids = _controlpoint.modified_by_ids,`
`    resolved_by_id = _controlpoint.resolved_by_id,`
`    drawing_id = _controlpoint.drawing_id,`
`    layer_id = _controlpoint.layer_id,`
`    inspection_guid_lock = _controlpoint.inspection_guid_lock`
`  WHERE guid = _controlpoint.guid;`

`  --Update journalItem with both old and new controlpoint_level`
`  --as well as old drawing_id and layer_id if any of these has changed`
`  --This is used for statistics and for showing historic effects of each journal item`
`  UPDATE main.journal_item`
`  SET`
`    old_controlpoint_level_id = _last_controlpoint_level_id,`
`    new_controlpoint_level_id = _controlpoint.controlpoint_level_id,`
`    old_drawing_id = _old_drawing_id,`
`    old_layer_id = _old_layer_id`
`  WHERE guid = _journal_item.guid;`


`  --Add/update any controlpoint events that should be collected`
`  INSERT INTO main.controlpoint_event`
`  (controlpoint_guid, controlpoint_event_type_id, journal_item_guid)`
`  SELECT `
`    _journal_item.controlpoint_guid, `
`    et.controlpoint_event_type_id, `
`    _journal_item.guid`
`  FROM main.journal_item_type_controlpoint_event_type et`
`  WHERE et.journal_item_type_id = _journal_item.journal_item_type_id`
`  ON CONFLICT ON CONSTRAINT controlpoint_event_pkey DO UPDATE `
`    SET journal_item_guid = EXCLUDED.journal_item_guid;`

`  --If this journalItem belong to an inspection, we will update the inspection`
`  --with the next controlpointIdentifier. This will also update modified_at`
`  --so that subscribed clients will get updated inspection statistics via get_inspections()`
`  IF _journal_item.inspection_guid IS NOT NULL THEN`
`    UPDATE main.inspection`
`    SET modified_at = now(), next_controlpoint_identifier = _controlpoint.identifier + 1`
`    WHERE guid = _journal_item.inspection_guid;`
`  END IF;`

`  RETURN 1;`
`END`
`$function$;`

`---------------------------------`

`DROP FUNCTION IF EXISTS main.tr_journal_item__update_controlpoint CASCADE;`

`CREATE OR REPLACE FUNCTION app_api.create_journal_item(_user_account_id integer, _controlpoint_guid uuid, _journal_item_type_id integer, _guid uuid DEFAULT NULL::uuid, _thumbnail_file_guid uuid DEFAULT NULL::uuid, _signature_file_guid uuid DEFAULT NULL::uuid, _apply_thumbnail_on_controlpoint boolean DEFAULT true, _apply_signature_on_controlpoint boolean DEFAULT true, _properties json DEFAULT NULL::json, _local_properties json DEFAULT NULL::json, _parent_controlpoint_guid uuid DEFAULT NULL::uuid, _symbol_id integer DEFAULT NULL::integer, _shapes json DEFAULT NULL::json, _remove_shape_guids uuid[] DEFAULT NULL::uuid[], _add_state_ids integer[] DEFAULT NULL::integer[], _remove_state_ids integer[] DEFAULT NULL::integer[], _create_deviations jsonb[] DEFAULT NULL::jsonb[], _resolve_deviation_guids uuid[] DEFAULT NULL::uuid[], _file_refs jsonb[] DEFAULT NULL::jsonb[], _products jsonb[] DEFAULT NULL::jsonb[], _product_intent_id integer DEFAULT NULL::integer, _add_snippets jsonb[] DEFAULT NULL::jsonb[], _remove_snippets jsonb[] DEFAULT NULL::jsonb[], _add_qr_tokens text[] DEFAULT NULL::text[], _remove_qr_tokens text[] DEFAULT NULL::text[], _drawing_id integer DEFAULT NULL::integer, _layer_id integer DEFAULT NULL::integer, _elapsed_seconds double precision DEFAULT NULL::double precision, _inspection_guid uuid DEFAULT NULL::uuid, _sharing jsonb DEFAULT NULL::jsonb, _client_timestamp timestamp with time zone DEFAULT NULL::timestamp with time zone, _target_controlpoint_level_id integer DEFAULT NULL::integer)`
` RETURNS uuid`
` LANGUAGE plpgsql`
` SECURITY DEFINER`
`AS $function$`
`DECLARE `
`  _taken_qr_tokens text[];`
`  _missing_qr_tokens text[];`
`  _original_add_qr_tokens text[];`
`  _journal_item main.journal_item;`
`BEGIN`
`  _guid = COALESCE(_guid, pgcrypto.gen_random_uuid());`

`  --If this guid already exists AND represents a journalItem with same controlpointGuid`
`  --We will assume that this is not a unique key violation, but instead an attempt to save the same `
`  --journalItem again. In that case we will return as if everything worked out great.`
`  --This could happen if a client lost connection while waiting for a response on the first attempt`
`  PERFORM *`
`  FROM main.journal_item`
`  WHERE guid = _guid `
`  AND controlpoint_guid = _controlpoint_guid;`

`  IF FOUND THEN `
`    RETURN _guid;`
`  END IF;`
`  -------------------------------------------------------------------------------------------------`

`  --Ensure that symbol_id exists, otherwise empty the field`
`  PERFORM * `
`  FROM main.symbol `
`  WHERE id = _symbol_id;`

`  IF NOT FOUND THEN `
`    _symbol_id = NULL;`
`  END IF;`

`  --Ensure that all qr_tokens in _add_qr_tokens `
`  --exists and are not already connected to any controlpoint in another drawing_id`
`  --This has to be perfoemd in a "soft way", i.e. adjust and log any problems, but save the journalItem,`
`  --otherwise we would get into trouble when devcies comes online and starts syncing failed journalItems`
`  IF _add_qr_tokens IS NOT NULL THEN`
`    _original_add_qr_tokens = _add_qr_tokens;`

`    SELECT drawing_id `
`    INTO _drawing_id  `
`    FROM main.controlpoint `
`    WHERE guid = _controlpoint_guid;`
`    `
`    --Identify any qr-tokens that are already connected to controlpoints on other drawings`
`    SELECT array_agg(DISTINCT t.qr_token)`
`    INTO _taken_qr_tokens`
`    FROM main.controlpoint_qr_token t`
`    JOIN UNNEST(_add_qr_tokens) as addqr ON addqr = t.qr_token`
`    JOIN main.controlpoint cp ON cp.guid = t.controlpoint_guid AND cp.drawing_id <> _drawing_id;`
`   `
`   --Remove any problematic qr codes from the add-array`
`    IF array_length(_taken_qr_tokens, 1) > 0 THEN `
`      SELECT array_agg(token)`
`      INTO _add_qr_tokens`
`      FROM unnest(_add_qr_tokens) as token`
`      WHERE token <> ALL(_taken_qr_tokens);`
`    END IF;`

`    --Find any tokens in the adjusted-array which are missing from qr_token`
`    SELECT array_agg(adjusted)`
`    INTO _missing_qr_tokens `
`    FROM UNNEST(_add_qr_tokens) adjusted `
`    LEFT JOIN main.qr_token t ON t.token = adjusted `
`    WHERE t.token IS NULL;`

`   --Remove any missing qr codes from the adjusted-array`
`    IF array_length(_missing_qr_tokens, 1) > 0 THEN `
`      SELECT array_agg(token)`
`      INTO _add_qr_tokens`
`      FROM unnest(_add_qr_tokens) as token`
`      WHERE token <> ALL(_missing_qr_tokens);`
`    END IF;`
`  END IF;`


`  INSERT INTO main.journal_item`
`  (`
`    guid,`
`    controlpoint_guid,`
`    journal_item_type_id,`
`    thumbnail_file_guid,`
`    signature_file_guid,`
`    apply_thumbnail_on_controlpoint,`
`    apply_signature_on_controlpoint,`
`    parent_controlpoint_guid,`
`    properties,`
`    local_properties,`
`    symbol_id,`
`    shapes,`
`    remove_shape_guids,`
`    add_state_ids,`
`    remove_state_ids,`
`    created_by_id,`
`    create_deviations,`
`    resolve_deviation_guids,`
`    products,`
`    product_intent_id,`
`    add_snippets,`
`    remove_snippets,`
`    add_qr_tokens,`
`    remove_qr_tokens,`
`    created_at,`
`    new_drawing_id,`
`    new_layer_id,`
`    elapsed_seconds,`
`    inspection_guid,`
`    sharing,`
`    client_timestamp,`
`    target_controlpoint_level_id`
`  )`
`  VALUES (`
`    _guid,`
`    _controlpoint_guid,`
`    _journal_item_type_id,`
`    _thumbnail_file_guid,`
`    _signature_file_guid,`
`    COALESCE(_apply_thumbnail_on_controlpoint, true),`
`    COALESCE(_apply_signature_on_controlpoint, true),`
`    _parent_controlpoint_guid,`
`    _properties,`
`    _local_properties,`
`    _symbol_id,`
`    _shapes,`
`    _remove_shape_guids::uuid[],`
`    _add_state_ids::smallint[],`
`    _remove_state_ids::smallint[],`
`    _user_account_id,`
`    _create_deviations,`
`    _resolve_deviation_guids,`
`    _products,`
`    _product_intent_id,`
`    _add_snippets,`
`    _remove_snippets,`
`    _add_qr_tokens,`
`    _remove_qr_tokens,`
`    clock_timestamp(),`
`    _drawing_id,`
`    _layer_id,`
`    _elapsed_seconds,`
`    _inspection_guid,`
`    _sharing,`
`    _client_timestamp,`
`    _target_controlpoint_level_id`
`  )`
`  ON CONFLICT (guid) DO NOTHING`
`  RETURNING * INTO _journal_item;`

`  --log any qr_token problems if they exists.`
`  --N.B. logging can not be performed before journal_item exists due to FK constraint`
`  IF array_length(_taken_qr_tokens, 1) > 0 OR array_length(_missing_qr_tokens, 1) > 0 THEN `
`    INSERT INTO main.journal_item_qr_token_fail (`
`      journal_item_guid, `
`      original_qr_tokens, `
`      taken_qr_tokens, `
`      missing_qr_tokens, `
`      adjusted_qr_tokens`
`    )`
`    VALUES (`
`      _guid, `
`      _original_add_qr_tokens, `
`      _taken_qr_tokens, `
`      _missing_qr_tokens, `
`      _add_qr_tokens`
`    );`
`  END IF;`


`  IF _file_refs IS NOT NULL THEN`
`    INSERT INTO main.journal_item_file_ref (`
`      journal_item_guid,`
`      file_guid,`
`      tag,`
`      media_album_id,`
`      intent_id,`
`      created_by_id`
`    )`
`    SELECT`
`      _guid,`
`      (file_ref_object->>'file_guid')::uuid,`
`      file_ref_object->>'tag',`
`      (file_ref_object->>'media_album_id')::int,`
`      COALESCE((file_ref_object->>'intent_id')::smallint, 5),`
`      _user_account_id`
`    FROM unnest(_file_refs) as file_ref_object`
`    ON CONFLICT (journal_item_guid, file_guid) DO NOTHING;`
`  END IF;`

`  PERFORM main.process_journal_item(_journal_item::main.journal_item);`

`  RETURN _guid;`
`END;`
`$function$;`

`-----------------`
`CREATE OR REPLACE FUNCTION main.tr_controlpoint__thumbnail_file_ref()`
` RETURNS trigger`
` LANGUAGE plpgsql`
`AS $function$`
`BEGIN`
`/*  IF NEW.thumbnail_file_guid IS NOT NULL THEN`
`    INSERT INTO main.controlpoint_file_ref`
`    (controlpoint_guid, file_guid, intent_id)`
`    VALUES (NEW.guid, NEW.thumbnail_file_guid, 5)`
`    ON CONFLICT ON CONSTRAINT controlpoint_file_ref_intent_id_key DO UPDATE`
`      SET file_guid = NEW.thumbnail_file_guid;`
`  END IF;`

`  IF NEW.signature_file_guid IS NOT NULL THEN`
`    INSERT INTO main.controlpoint_file_ref`
`    (controlpoint_guid, file_guid, intent_id)`
`    VALUES (NEW.guid, NEW.signature_file_guid, 6)`
`    ON CONFLICT ON CONSTRAINT controlpoint_file_ref_intent_id_key DO UPDATE`
`      SET file_guid = NEW.signature_file_guid;`
`  END IF;`
`*/`
`  RETURN NEW;`
`END;`
`$function$`
`;`
